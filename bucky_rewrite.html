<!DOCTYPE html>
<head>
<script src="control.js"></script>
<script src="enemy.js"></script>
<script src="interactives.js"></script>
<script src="player.js"></script>
<script src="utility.js"></script>
<script src="maps.js"></script>

<script type = "text/javascript">

/* BugList {Come back to, maybe? :(  }
-- Timer's automatic removal can cause items first in UpdateManager to not draw for a frame
---- this same bug can cause some element's positions to not get updated.
*/

// debugging
var debugging = 		false;
var debugging_text = 	true;
var music = 			false;

	levelMusic = new Audio('music/canopy.ogg'); 
	levelMusic.volume = 0.5;
	levelMusic.addEventListener('ended', function() {
	    this.currentTime = 0;
	    if(music) this.play();
	}, false);
	if(music) levelMusic.play();





// Global Variables
var	IN_ACTION = 		10;
var	DONE = 				11;

var	IMAGE_SHEET = 		12;
var	MOVEMENT = 			13;

var	DEAD = 				1;
var	ALIVE = 			2;

var HIT =				3;
var UNHIT = 			4;
var WALKING = 			5;

var ATTACKING =			3;
var JUMPING =			4;
var STILL =  			6;

var LEFT = 				1;
var RIGHT = 			2;

var ctx;
var blocksize = 		25;
var imageMap;
var GRAVITY = 			0.2;
var UpdateManager = 	new Array();

var statsBox = 			null;
var framecount = 		0;
var physicsTimer = 		null;
var physExecuteMs = 	7;
var drawExecuteMs = 	16.667;
var physicsDelta = 		physExecuteMs;
var drawTimer = 		null;
var graphics_drawTimer= null;
var drawDelta = 		null;
var drawFps =			60;
var statsDiv;
var itemTypes;

function Game(x_boundary, y_boundary){
	this.boundary =   				{};
	this.boundary.x = 				x_boundary;	// x-coord boundary
	this.boundary.y = 				y_boundary;	// y-coord boundary
	this.clearColor = 				"#7ADAE1";	// initial clear color is null
	this.state = 					null;
	this.drawOffset = 				0;
	this.drunkTime = 				0;
	this.drunkPeriod = 				5;
	this.drunkTimeIncrement = 		0.05;
	this.drunkStrength = 			0;
	this.drunkStrengthIncrement = 	1;
	this.drunkStrengthLimit = 		50;
	this.physCorrect = 				1;
	this.drawCorrect = 				1;
	this.initialized = 				null;
	this.camera = 					{};
	this.camera.offset = 			0;
	this.camera.boundary = 			{};
	this.camera.boundary.left = 	200;
	this.camera.boundary.right = 	350;
	this.camera.offset = 			0;

	this.update = function(x_change){
   		this.camera.offset = x_change;
   		this.drawOffset += x_change;
   	}

	this.resetGame = function() {
		window.cancelAnimationFrame(animId);
		begin_game();
	}

	this.clearScreen = function() { 
		ctx.fillStyle = this.clearColor;
		ctx.fillRect(0, 0, this.boundary.x, this.boundary.y);
	}
}


function page_load() {
	var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel";
	if (document.attachEvent){
		document.attachEvent("on"+mousewheelevt, function(e) {mouse_scroll(e)}, false);
	}else if (document.addEventListener){
		document.addEventListener(mousewheelevt, function(e) {mouse_scroll(e)}, false);
	}
	begin_game();
}

function begin_game() {

	// play muzak

	UpdateManager = new Array();

	statsDiv = document.getElementById("fps");

	// reset timing variables to prevent odd behavior upon reset
	physicsDelta = 		physExecuteMs;
	drawTimer = 		null;
	graphics_drawTimer= null;
	drawDelta = 		null;
	drawFps =			60;


	// Define individual tilesets
	GrassTileset  = new TileSet(
		new Array(
			"images/grass_tileset/grass_top_left.png", 
			"images/grass_tileset/grass_top_middle.png", 
			"images/grass_tileset/grass_top_right.png", 
			"images/grass_tileset/grass_middle_left.png", 
			"images/grass_tileset/ground_tile.png", 
			"images/grass_tileset/grass_middle_right.png", 
			"images/grass_tileset/grass_bottom_left.png", 
			"images/grass_tileset/grass_bottom_middle.png", 
			"images/grass_tileset/grass_bottom_right.png", 
			"images/grass_tileset/grass_top_single.png", 
			"images/grass_tileset/grass_left_single.png", 
			"images/grass_tileset/grass_right_single.png", 
			"images/grass_tileset/grass_bottom_single.png", 
			"images/grass_tileset/grass_middle_single_horizontal.png", 
			"images/grass_tileset/grass_middle_single_vertical.png",
			"images/grass_tileset/grass_single.png"
		),
		1,
		"full"
	);

	RockTileset = new TileSet( 
		new Array(
			"images/rock_tileset/platform.png", 
			"images/rock_tileset/platform_underneath.png"
		), 
		2, 
		"dual"
	);

	SpikeTileset = new TileSet( 
		new Array(
			"images/spike_tileset/spike_pit.png", 
			"images/spike_tileset/spike_lower.png"
		), 
		4, 
		"dual"
	);

	BeerTileset = new TileSet( 
		new Array(
			"images/items/beer_mug.png"
		), 
		3, 
		"single"
	);

	ItemBlockTileset = new TileSet( 
		new Array(
			"images/items/item_block.png",
			"images/items/item_block_hit.png"
		), 
		6, 
		"single"
	);

	// define different tile collections
	collideTypes = new Array(GrassTileset, RockTileset);
	itemTypes = new Array(BeerTileset);
	TilesetArrays = new Array(GrassTileset, RockTileset, SpikeTileset);

	// get a reference to the canvas
	var canvas = document.getElementById("draw_canvas");
	ctx = canvas.getContext("2d");

	// declare initial objects (Controller, Game, Player, etc)
	Controller = new Control();
	BuckyGame = new Game(1200, 600);
	Buckingham = new Player(225, 300, BuckyGame);

	TestInfo = new InfoBox(500, 100, "Bacon ipsum dolor sit amet brisket pork belly short loin, sausage ham hock kielbasa swine pork.");
	UpdateManager.push(TestInfo);

	PlayButton = new Button(500, 450, 100, 30, "#000000", "#CCCCCC", "Play Game");
	ResetButton = new Button(650, 10, 120, 30, "#000000", "#CCCCCC", "Reset Game", 
		function(){ 
			clearInterval(statsInterval);
			clearInterval(physInterval);
			BuckyGame.resetGame();
		}
	);

	UpdateManager.push(ResetButton);

	// PLACEABLE ANIMATION TEST
	TestPlaceableAnimation = new PlaceableAnimation(
		250, 
		-25, 
		new Array("images/animations/explosion/explosion1.gif", "images/animations/explosion/explosion2.gif", "images/animations/explosion/explosion3.gif", "images/animations/explosion/explosion4.gif", "images/animations/explosion/explosion5.gif", "images/animations/explosion/explosion6.gif", "images/animations/explosion/explosion7.gif", "images/animations/explosion/explosion8.gif", "images/animations/explosion/explosion9.gif", "images/animations/explosion/explosion10.gif", "images/animations/explosion/explosion11.gif", "images/animations/explosion/explosion12.gif", "images/animations/explosion/explosion13.gif", "images/animations/explosion/explosion14.gif", "images/animations/explosion/explosion15.gif", "images/animations/explosion/explosion16.gif", "images/animations/explosion/explosion17.gif", "images/animations/explosion/explosion18.gif", "images/animations/explosion/explosion19.gif", "images/animations/explosion/explosion20.gif", "images/animations/explosion/explosion21.gif", "images/animations/explosion/explosion22.gif", "images/animations/explosion/explosion23.gif", "images/animations/explosion/explosion24.gif"
		),
		60, 
		true, 
		BuckyGame
	);

	UpdateManager.push(TestPlaceableAnimation);

	// define parallax background
	Background = new Parallax("images/backgrounds/test_background.jpg", 0.3, BuckyGame);

	// map already included by a separate map.js file
	imageMap = new Array(map.length);

	for(i = 0; i<map.length; i++){
		imageMap[i] = new Array(map[0].length);
	}

	// process map file for use in drawing, and logic segments
	for(var i = 0; i<map.length; i++){
		for(var k = 0; k<map[i].length; k++){

			/***********************************************
			 PROCESS MAP FILE FOR EACH TILESET, GENERATING
			 AN IMAGE MAP ARRAY.
			 ***********************************************/
			for(j = 0; j<TilesetArrays.length; j++){
				var checkArray = [  [  			0		     , (i-1>=0)?map[i-1][k]:0	 	  ,  			0		   				 ],
									[ (k-1>=0)?map[i][k-1]:0 ,          map[i][k] 	      	  , (k+1<map[i].length)?(map[i][k+1]):0  ],
									[  			0		     , (i+1<map.length)?map[i+1][k]:0 ,  			0		   				 ]  ];
				
				var result = TilesetArrays[j].getTile(checkArray);

				if(result){
					imageMap[i][k] = result;
				}
			}

			if(imageMap[i][k] == undefined) imageMap[i][k] = null;


			/***********************************************
			 PROCESS MAP FILE FOR ITEMS
			 ***********************************************/
			
			for(j = 0; j<itemTypes.length; j++){
				if(map[i][k] == itemTypes[j].num){
					UpdateManager.push(new Item(k*blocksize, i*blocksize, itemTypes[j].getTile()));
				}
			}

			/************************************************
			 PROCESS INDIVIDUAL TILE ITEMS THAT AREN'T IN
			 A COLLECTION
			 ************************************************/
			 // Item block
			 if(map[i][k] == ItemBlockTileset.num){
			 	UpdateManager.push(new ItemBlock(k*blocksize, i*blocksize, 3, ItemBlockTileset.tileArray[0], ItemBlockTileset.tileArray[1]));
			 }

			 // Spike block
			 if(map[i][k] == 4){
			 	UpdateManager.push(new HurtBlock(k*blocksize, i*blocksize, blocksize, blocksize) );
			 }

			 // Enemy
			 if(map[i][k] == 5){
			 	UpdateManager.push(new Enemy(k*blocksize, i*blocksize, BuckyGame) );
			 }
		}	
	}

	/***********************************
	 FIRST SCREENING OF COLLISION BLOCKS
	 ***********************************/

	for(var i = 0; i<map.length; i++){ // map y
		var start = 0;
		var numfound = 0;
		for(var k = 0; k<map[i].length; k++){ // map x
			var blockfound = false;
			// scan along the map file horizontally looking for block strips. When found,
			// continue until you don't find one. If it's at least one block, create the
			// new large block.

			for(j = 0; j<collideTypes.length; j++){
				if(map[i][k] == collideTypes[j].num){
					blockfound = true;
					numfound ++;
					//UpdateManager.push(new Block(k*blocksize, i*blocksize, blocksize, blocksize));
				}
			}

			if(!blockfound && numfound > 0){
				UpdateManager.push(new Block(start*blocksize, i*blocksize, numfound*blocksize, blocksize));
				start = k+1;
				numfound = 0;
			} else if(!blockfound) {
				start = k+1;
				numfound = 0;
			}

		}
	}

	/************************************
	 SECOND SCREENING OF COLLISION BLOCKS
	 COMBINE SIMILAR GROUPS TO REDUCE THE
	 NUMBER OF COLLISION SQUARES/RECTANGLES
	 ************************************/

	 // check each strip of blocks in the UpdateManager to see if they are identical, except
	 // shifted up or down one row. These we can combine into larger rectangles.
	 // This step can be considered relatively slow, but it only happens once upon loading
	 // a map, so it doesn't become a problem.

	 u_length = UpdateManager.length;  // copy the updatemanager length here, as it can change in the loop
	 for(j = 0; j<5; j++){	// Perform 5 passes of the second screening type.
		 for(i = 0; i<u_length; i++){
		 	first = UpdateManager[i];
		 	if(first instanceof Block){
		 		for(k = i; k<u_length; k++){
		 			second = UpdateManager[k];
		 			if(second instanceof Block && i != k){
		 				if(first.position.x == second.position.x 
		 					&& first.position.y + first.height == second.position.y
		 					&& first.width == second.width){
		 					// match was found, combine the rectangles
		 					new_x = first.position.x;
		 					new_y = first.position.y;
		 					new_w = first.width;
		 					new_h = first.height + second.height;
		 					// splice in new rectangle, remove the two old rectangles
		 					UpdateManager.splice(i, 1, new Block(new_x, new_y, new_w, new_h));
		 					UpdateManager.splice(k, 1);
		 				}
		 			}
		 		}
		 	}
		}
	}


	caller();	// start the physics and drawing loops to start game
}

function caller(){
	physInterval = setInterval(physics, physExecuteMs);
	if(debugging || true){
		statsInterval = setInterval(stats, 200);
	}
	draw_world();
}

function physics(){

	/******************************************
	 PHYSICS TIMER, USED FOR ACCURATE MOVEMENT
	 ******************************************/

	if(physicsTimer == null){
		physicsTimer = new Date().getTime();
	} else {
		physicsDelta = new Date().getTime()-physicsTimer;
		physicsTimer = new Date().getTime();
		BuckyGame.physCorrect = BuckyGame.physCorrect * (4/5) + physicsDelta/physExecuteMs * (1/5);
		if(BuckyGame.physCorrect > 3) BuckyGame.physCorrect = 3;
	}
	// print stats out to the screen
	Buckingham.physics();

	for(var i = 0; i<UpdateManager.length; i++){
		UpdateManager[i].physics(BuckyGame.camera.offset);
	}

	// for(var i = 0; i<UpdateManager.length; i++){
	// 	if(UpdateManager[i] instanceof Enemy){
	// 		UpdateManager[i].physics();
	// 		if(UpdateManager[i].state == DEAD){
	// 			UpdateManager.splice(i, 1);
	// 		}
	// 	} else if(UpdateManager[i] instanceof Button){
	// 		UpdateManager[i].clicked();
	// 	}
	// }

}

function stats() {

	/******************************************
	 GENERATE SOME STATISTICS FOR SHOWING ONSCREEN
	 ******************************************/
	 // currently unused, replaced by canvas infobox.
}


function draw_world() { 

	/******************************************
	 GRAPHICS TIMER, USED FOR STATS DISPLAY
	 ******************************************/

	if(graphics_drawTimer == null){
		graphics_drawTimer = new Date().getTime();
	} else {
		drawDelta = new Date().getTime()-graphics_drawTimer;
		graphics_drawTimer = new Date().getTime(); 
		drawFps = drawFps * (49/50) + 1000/drawDelta * 1/50;
		if(drawFps > 1000) drawFps = 60; // sanity check (check for infinity)
		BuckyGame.drawCorrect = BuckyGame.drawCorrect * (4/5) + drawDelta/drawExecuteMs * (1/5);
		if(BuckyGame.drawCorrect > 2) BuckyGame.drawCorrect = 2;
	}
	
	BuckyGame.clearScreen();

	Background.draw();

	BuckyGame.drunkTime += BuckyGame.drunkTimeIncrement;

	// draw tile image map
	for(var i = 0; i<map.length; i++){
		for(var k = 0; k<map[i].length; k++){
			if( (k+1)*blocksize+BuckyGame.drawOffset > 0 && (k-1)*blocksize+BuckyGame.drawOffset<BuckyGame.boundary.x){
				if(imageMap[i][k] != null) ctx.drawImage(imageMap[i][k], Math.floor(k*blocksize+BuckyGame.drawOffset), Math.floor((i*blocksize)+Math.sin(BuckyGame.drunkTime+(k*BuckyGame.drunkPeriod)/blocksize)*BuckyGame.drunkStrength));
			}
		}
	}

	/********************************************
	 RUN THROUGH UPDATEMANAGER ITEMS
	 DRAW DRAWABLE ITEMS, UPDATE OTHERS
	 *******************************************/

	for(var i = 0; i<UpdateManager.length; i++){
		temp = UpdateManager[i];
		if(temp instanceof Block 
			|| temp instanceof ItemBlock 
			|| temp instanceof Item
			|| temp instanceof Enemy
			|| temp instanceof InfoBox
			|| temp instanceof HurtBlock
			|| temp instanceof PlaceableAnimation){
			temp.draw();
		}
	}

	// for(var i = 0; i<UpdateManager.length; i++){
	// 	temp = UpdateManager[i];
	// 	if (temp instanceof Timer){
	// 		temp.physics(BuckyGame.camera.offset);
	// 	}
	// }

	Buckingham.draw();
	ResetButton.draw();

	// draw out stats container
	if(debugging_text || debugging){
		if(framecount == 0){
			statsBox = new InfoBox(BuckyGame.boundary.x-260, 10, 		 
			  String(
			  	  "PhysDelta:     " 
			+ physicsDelta 
			+ " \n PhysCorrect:   " 
			+ BuckyGame.physCorrect.toFixed(2) 
			+ " \n DrawCorrect:   "
			+ BuckyGame.drawCorrect.toFixed(2)
			+ " \n drawFPS:       " 
			+ drawFps.toFixed(2)
			+ " \n BuckyVelX :    "
			+ Buckingham.vel.x.toFixed(2)
			+ " \n UpdateManager: "
			+ UpdateManager.length));
			framecount = 6;
		}
		framecount--;
		statsBox.draw();
		
	}
	

	animId = window.requestAnimationFrame(draw_world);

}


window.addEventListener('keydown',key_event,true);
window.addEventListener('keyup',key_event_up,true);
window.addEventListener('mouseup', mouse_up, false);
window.addEventListener('mousedown', mouse_down, false);

</script> 
</head>
<body style="overflow: hidden;"  onload="page_load()">

<canvas onmousemove="mouse_move(event)" onmousedown="mouse_press(event)" id="draw_canvas" width="1200" height="600" tabindex="1"></canvas>

<div id="fps" style="width: 800px; display: inline-block; vertical-align: top;"></div>

<script type="text/javascript">
	gameCanvas = document.getElementById("draw_canvas");
  	document.getElementById("draw_canvas").focus();
</script>

</body>
</html>

